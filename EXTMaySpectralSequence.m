//
//  EXTMaySpectralSequence.m
//  Ext Chart
//
//  Created by Eric Peterson on 7/9/13.
//  Copyright (c) 2013 Harvard University. All rights reserved.
//

#import "EXTMaySpectralSequence.h"
#import "EXTTriple.h"
#import "EXTDifferential.h"

@interface EXTMayTag : NSObject <NSCopying>
@property (assign) int i, j;
+(EXTMayTag*) tagWithI:(int)i J:(int)j;
-(NSString*) description;
-(NSUInteger) hash;
@end

@implementation EXTMayTag
@synthesize i, j;
+(EXTMayTag*) tagWithI:(int)i J:(int)j {
    EXTMayTag *ret = [EXTMayTag new];
    ret.i = i; ret.j = j;
    return ret;
}
-(NSString*) description {
    return [NSString stringWithFormat:@"h_{%d,%d}",i,j];
}
-(EXTMayTag*) copyWithZone:(NSZone*)zone {
    EXTMayTag *ret = [[EXTMayTag allocWithZone:zone] init];
    ret.i = i; ret.j = j;
    return ret;
}
-(BOOL) isEqual:(id)object {
    if ([object class] != [EXTMayTag class])
        return FALSE;
    return ((((EXTMayTag*)object)->i == i) &&
            (((EXTMayTag*)object)->j == j));
}
-(NSUInteger) hash {
    long long key = i;
	key = (~key) + (key << 18); // key = (key << 18) - key - 1;
    key += j;
	key = key ^ (key >> 31);
	key = key * 21; // key = (key + (key << 2)) + (key << 4);
	key = key ^ (key >> 11);
	key = key + (key << 6);
	key = key ^ (key >> 22);
	return (int) key;
}
@end




@implementation EXTMaySpectralSequence

+(EXTTriple*) followSquare:(EXTTriple*)location order:(int)order {
    return [EXTTriple tripleWithA:(location.a+order) B:(location.b*2) C:(location.c*order)];
}

-(EXTMatrix*) squaringMatrix:(int)order location:(EXTTriple*)location {
    // we know the following three facts about the squaring operations:
    // Sq^n(xy) = sum_{i=0}^n Sq^i x Sq^{n-i} y, (Cartan)
    // Sq^0(h_ij) = h_i(j+1),                    (Nakamura on Sq^0)
    // Sq^1(h_ij) = h_ij^2.                      (Definition of Sq^n on n-class)
    //
    // since we're generated by classes of degree 1, this completely determines
    // the squaring structure everywhere, by iteratively splitting apart a
    // square until we get down to just Sq^0s and Sq^1s.
    
    EXTTerm *startTerm = [self findTerm:location],
            *endTerm = [self findTerm:[EXTMaySpectralSequence followSquare:location order:order]];
    for (int i = 0; i < startTerm.size; i++) {
        EXTMayTag *tag = startTerm.names[i];
        
    }
    
    return nil;
}

// applies Sq^(order) to the terms at location to get a differential on page page
-(void) calculateNakamura:(int)order location:(EXTTriple*)location page:(int)page {
    // we need to look up:
    // * the differential on E_new off the target location of Sq^order
    // * the differential on E_old off location
    // * the matrix describing the map Sq^order on E_new
    // * the matrix describing the map Sq^order on E_old
    //
    // then, we apply: d_page (Sq^order x) = Sq^order (d_{page-order} x).

    return;
}

-(void) propagateNakamura:(int)page generators:(NSMutableArray*)generators {
    // then propagate with nakamura's lemma / the Cartan formula until exhausted
    
    return;
}

+(EXTMaySpectralSequence*) fillToWidth:(int)width {
    EXTMaySpectralSequence *sseq = (EXTMaySpectralSequence*)[EXTMaySpectralSequence sSeqWithUnit:[EXTTriple class]];
    
    [sseq.zeroRanges addObject:[EXTZeroRangeStrict newWithSSeq:sseq]];
    int last1Index = 0;
    
    // start by adding the polynomial terms h_{i,j}
    for (int i = 1; ; i++) {
        
        // if we've passed outside of the width, then quit.
        if ((1 << i)-2 > width)
            break;
        
        for (int j = 0; ; j++) {
            // calculate the location of the present term
            int A = 1, B = (1 << j)*((1 << i) - 1), C = i;
            if (B - 1 > width)
                break;
            
            int limit = ((i == 1) && (j == 0)) ? width : width/(B-1);
            
            [sseq addPolyClass:[EXTMayTag tagWithI:i J:j] location:[EXTTriple tripleWithA:A B:B C:C] upTo:limit];
        }
        
        if (i == 1)
            last1Index = [sseq.names count];
    }
    
    // then add their d1 differentials
    for (int index = 0; index < sseq.names.count; index++) {
        EXTMayTag *tag = sseq.names[index];
        int i = tag.i, j = tag.j;
        
        // these elements are genuinely primitive, so never support diff'ls.
        if (i == 1)
            continue;
        
        EXTTriple *location = sseq.locations[index];
        EXTTerm *target = [sseq findTerm:[EXTTriple followDiffl:location page:1]];
        EXTDifferential *diff = [EXTDifferential differential:[sseq findTerm:location] end:target page:1];
        EXTPartialDefinition *partial = [EXTPartialDefinition new];
        partial.inclusion = [EXTMatrix identity:1];
        partial.differential = [EXTMatrix matrixWidth:1 height:target.size];
        
        // the formula for the May d_1 comes straight from the Steenrod
        // diagonal: d_1 h_{i,j} = sum_{k=1}^{i-1} h_{k,i-k+j} h_{i-k,j}
        for (int k = 1; k <= i-1; k++) {
            EXTMayTag *tagLeft = [EXTMayTag tagWithI:k J:(i-k+j)],
                      *tagRight = [EXTMayTag tagWithI:(i-k) J:j];
            int leftIndex = [sseq.names indexOfObject:tagLeft],
                rightIndex = [sseq.names indexOfObject:tagRight];
            EXTMatrix *product = [sseq productWithLeft:sseq.locations[leftIndex] right:sseq.locations[rightIndex]];
            partial.differential = [EXTMatrix sum:partial.differential with:product];
        }
        
        [diff.partialDefinitions addObject:partial];
        [sseq addDifferential:diff];
    }
    
    // propagate the d1 differentials with Leibniz's rule
    [sseq propagateLeibniz:sseq.locations page:1];
    
    [sseq computeGroupsForPage:0];
    [sseq computeGroupsForPage:1];
    [sseq computeGroupsForPage:2];
    
    return sseq;
}

@end
